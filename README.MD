# Server Monitor & Bootstrap

![ShellCheck](https://github.com/ger-balakirau/bash-server-monitor-lite/actions/workflows/shellcheck.yml/badge.svg)

Набор bash-скриптов для:

- **подготовки системы** (bootstrap: установка утилит);
- **мониторинга сервера и сервисов** (HTTP/CPU/RAM/Disk/Swap/Docker);
- **отправки алертов в Telegram**.

Проект рассчитан на Linux-системы и используется как:

- **cron-задача**;
- **systemd unit / timer**;
- **ручной диагностический инструмент**.

---

## Почему bash-скрипты, а не Zabbix / Prometheus и аналоги

Решение ориентировано на сценарии, где:

- инфраструктура ограничена (например, VPS с 1 vCPU и ~2 GB RAM);
- критична минимальная нагрузка на CPU/память/диск;
- нужно быстрое MVP / временное решение без развёртывания полноценного стека;
- важно сократить затраты на инфраструктуру и сопровождение.

Полноценные системы мониторинга (Zabbix, Prometheus, Grafana и т.д.) обеспечивают существенно более широкий функционал, однако обычно требуют:

- постоянных агентов/демонов;
- дополнительного потребления ресурсов;
- времени на установку, настройку и поддержку;
- отдельной инфраструктуры для хранения метрик и визуализации.

В малых окружениях такие накладные расходы часто непропорциональны задаче.

---

## Ограничения

Данное решение **не** является заменой промышленным системам мониторинга и наблюдаемости (Zabbix/Prometheus/Grafana/Datadog и т.п.). Ограничения включают:

- отсутствие долгосрочного хранения и агрегации метрик;
- ограниченные возможности визуализации и аналитики;
- упрощённая модель алертинга;
- отсутствие распределённой архитектуры и масштабируемости.

Решение предназначено для:

- MVP;
- небольших проектов;
- тестовых и временных сред;
- одиночных серверов с жёсткими ресурсными ограничениями.

При росте нагрузки, требований к надёжности и аналитике рекомендуется переход на полноценную систему мониторинга.

---

## Структура проекта

```text
├── install.sh        # Установка в /opt + systemd/cron
├── bootstrap.sh      # Установка необходимых утилит/зависимостей
├── monitor.sh        # Мониторинг (CPU, RAM, Disk, HTTP, Docker) + Telegram алерты
├── .env.example      # Пример конфигурации
├── Makefile          # Линт и простые тесты
├── tests/            # Моки и smoke-тесты
│   ├── run.sh         # Smoke-тесты
│   └── mocks/          # Моки systemctl/ss/curl
└── README.md
```

---

## Быстрый старт

### Варианты установки

1) Самый простой: один файл
```bash
scp monitor.sh user@server:/opt/monitor/
```

2) С `.env` рядом со скриптом
```bash
scp monitor.sh .env user@server:/opt/monitor/
```

3) Через `install.sh` (рекомендуется)
```bash
./install.sh
```
Скрипт:
- запускает `bootstrap.sh`;
- копирует `monitor.sh` и `.env.example` в `/opt/monitor` (создаёт `/opt/monitor/.env`, если его нет);
- если есть systemd — создаёт `monitor-lite.service` и `monitor-lite.timer`;
- если systemd нет — ставит cron в `/etc/cron.d/monitor-lite`.
Если нет ни systemd, ни cron — создаётся `run.sh` в `/opt/monitor`, его нужно запускать вручную (цикл с паузой 60 сек).

Примечание: если у вас строгая политика прав, можно заменить `chmod +x` на `chmod u+x` в `install.sh`.

### 1) Создать Telegram-бота и получить токен

1. В Telegram найдите бота **BotFather**.
2. Откройте чат и нажмите **Start**.
3. Введите команду: `/newbot`
4. BotFather попросит:
   - **Name**: любое имя (например, `Monitor`)
   - **Username**: уникальный username, **обязательно заканчивается на `bot`**, например `vasyan_monitor_bot`
5. В ответ вы получите **TOKEN**, вида: `123456789:AAHfL9xZk9xQ7...`

**Важно:** TOKEN — секрет. Не публикуйте его в GitHub, логах и скриншотах.

---

### 2) Узнать CHAT_ID

1. Перейдите в чат с вашим ботом и отправьте любое сообщение (например, `ping`).
2. Откройте в браузере (подставив TOKEN):

```text
https://api.telegram.org/bot<TOKEN>/getUpdates
```

3. Найдите фрагмент вида:

```json
"chat":{"id":123456789,...}
```

Это и есть ваш `TG_CHAT` (chat id).

---

### 3) Проверка отправки сообщения

```bash
TG_TOKEN="123456:ABC..." TG_CHAT="987654321" curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage"   -d chat_id="${TG_CHAT}"   -d text="Тест"
```

---

### 4) Клонировать репозиторий или скачать скрипт

```bash
git clone <repo-url>
cd <repo-dir>
```

---

### 5) Установка зависимостей (один раз)

Выберите вариант прав:

- Только для владельца файла (рекомендуется):
  ```bash
  chmod u+x bootstrap.sh
  ```
- Для всех пользователей:
  ```bash
  chmod +x bootstrap.sh
  ```

Запуск:

```bash
./bootstrap.sh
```

Скрипт автоматически:

- определит используемый дистрибутив Linux;
- выберет пакетный менеджер;
- установит недостающие утилиты и зависимости (включая `curl`, `jq`, `df`, `flock` и другие).

Опционально можно удалить `bootstrap.sh` после установки:

```bash
BOOTSTRAP_SELF_DELETE=1 ./bootstrap.sh
```

---

### 6) Подготовить конфигурацию (опционально)

```bash
cp .env.example .env
```

Минимально необходимое (если нужны оповещения и HTTP-проверка):

```dotenv
TG_TOKEN="PUT_YOUR_TELEGRAM_BOT_TOKEN_HERE"
TG_CHAT="PUT_YOUR_CHAT_ID_HERE"
URLS="https://example.com https://example.org/health"
```

`.env` можно не создавать — тогда скрипт работает с дефолтами, а Telegram-оповещения будут отключены, если не задать `TG_TOKEN`/`TG_CHAT` через окружение или прямо в скрипте.

Детальная настройка всех параметров — в разделе **Конфигурация (.env)** ниже.

---

### 7) Запустить монитор вручную

Выберите вариант прав:

```bash
chmod u+x monitor.sh
# или
chmod +x monitor.sh
```

Запуск:

```bash
./monitor.sh
```

---

## Конфигурация (.env)

### Минимально необходимое (если нужны оповещения/HTTP)

- `TG_TOKEN` — токен Telegram-бота (нужен для оповещений)
- `TG_CHAT` — chat id, куда отправлять сообщения (нужен для оповещений)
- `URLS` — список URL через запятую или пробел (нужен, если `ENABLE_HTTP_MONITOR=1`)

---

### Запуск без `.env` (один файл)

Можно запускать `monitor.sh` без `.env`. В этом случае используются дефолтные значения, а Telegram-оповещения будут отключены, пока не задать `TG_TOKEN` и `TG_CHAT`:

Варианты:

1. Передать через окружение при запуске:

```bash
TG_TOKEN="123:ABC" TG_CHAT="987654321" URLS="https://example.com https://example.org/health" ./monitor.sh
```

2. Прописать переменные прямо в начале `monitor.sh` (для однофайловой поставки).

---

### Пример расширенной конфигурации

Ниже — полный набор переменных, которые можно переопределять в `.env`. Все значения — **опциональны**.

```dotenv
# ============================================================
# Какие проверки включены (0/1)
# ============================================================
ENABLE_HTTP_MONITOR=1
ENABLE_HOST_MONITOR=1
ENABLE_DOCKER_MONITOR=0


# ============================================================
# HTTP monitor (нужно, если ENABLE_HTTP_MONITOR=1)
# ============================================================
# Несколько URL через запятую или пробел
URLS="http://example.com/ http://example.org/health"

# Таймаут запроса (сек)
HTTP_TIMEOUT=5

# Сколько ошибок подряд нужно, чтобы объявить "DOWN"
# (защита от кратковременных сетевых сбоев)
HTTP_FAIL_THRESHOLD=3

# Успешные коды: 200..399 (включая редиректы)
HTTP_OK_MIN=200
HTTP_OK_MAX=399


# ============================================================
# Host thresholds (проценты)
# ============================================================
CPU_WARN=90
MEM_WARN=90
DISK_WARN=80
SWAP_WARN=60


# ============================================================
# Docker monitor (нужно, если ENABLE_DOCKER_MONITOR=1)
# Список контейнеров через запятую: имена или container id
# ============================================================
CONTAINERS="nginx, mysql, redis"
```

---

## Web services detection

Скрипт проверяет распространенные web‑service через systemd и пишет в лог активные/неактивные списки:

- активные: `LOG_WEB_ACTIVE`
- неактивные: `LOG_WEB_INACTIVE`

Списки логируются только при изменениях, чтобы уменьшить шум.

Шаблонные юниты (`nginx@`, `apache2@`, `httpd@`) учитываются через их инстансы (`nginx@site.service`). Если инстансов нет, шаблон помечается как неактивный.

Ограничения: детект через systemd доступен только на systemd‑хостах. В non‑systemd окружениях (некоторые контейнеры, init‑системы) будет использован fallback по слушающим портам (80/443).

В HTTP‑оповещениях можно выводить списки активных/неактивных сервисов через плейсхолдеры `{WEB_ACTIVE}` и `{WEB_INACTIVE}` (настраивается в `.env`).

Пример логов:

```text
2025-01-01 12:00:00 [INFO] Web services active: nginx.service,apache2.service
2025-01-01 12:00:00 [WARN] Web services inactive: httpd.service
```

---

## Design decisions

- **JSON state**: хранит состояние между запусками (down/up, fail counters, алерты) без внешней БД.
- **Пороговые значения + гистерезис**: уменьшают “дребезг” при колебаниях около порога.
- **Оповещения и логи в env**: позволяют легко менять язык и формулировки без правки кода.
- **Безопасный jq**: значения из переменных передаются через `jq --arg/--argjson`, чтобы избежать поломок из‑за экранирования.

---

### Пояснения по настройкам

#### ENABLE_HTTP_MONITOR / ENABLE_HOST_MONITOR / ENABLE_DOCKER_MONITOR

Включают/выключают блоки проверок:

- `ENABLE_HTTP_MONITOR=1` — проверка доступности `URLS` и алертинг падения/восстановления
- `ENABLE_HOST_MONITOR=1` — метрики хоста (CPU/RAM/Disk/Swap) + алертинг превышений/восстановления
- `ENABLE_DOCKER_MONITOR=1` — мониторинг контейнеров из `CONTAINERS` (опционально)

Значения:

- `1` — включено
- `0` — выключено

---

#### HTTP monitor

Рекомендации:

- используйте **health endpoint** (например `/health`, `/ping`), который:
  - быстрый;
  - не зависит от тяжёлых внешних интеграций;
  - возвращает стабильный код ответа.

Параметры:

- `URLS` — несколько URL через запятую или пробел.
- `HTTP_TIMEOUT` — максимальное время ожидания ответа (сек).
- `HTTP_FAIL_THRESHOLD` — число ошибок подряд, после которого сайт считается недоступным.
  - Это снижает шум от кратковременных сетевых проблем.
- `HTTP_OK_MIN` / `HTTP_OK_MAX` — диапазон “успешных” HTTP-кодов.
  - По умолчанию `200..399` (редиректы не считаются ошибкой).

Дополнительные оповещения:

- если `URLS` доступен, но локальные web‑службы остановлены — отправляется отдельное предупреждение;
- при восстановлении web‑служб (при доступном URL) — отправляется сообщение о восстановлении.

---

#### Host thresholds

Пороги задаются в процентах:

- `CPU_WARN` — алерт при высокой загрузке CPU
- `MEM_WARN` — алерт при высокой загрузке RAM (используется `MemAvailable`)
- `DISK_WARN` — алерт при заполнении корневой FS (`/`)
- `SWAP_WARN` — алерт по swap

Восстановление (“recovery”) в скрипте сделано с гистерезисом:

- CPU/RAM: порог - 10%
- Disk: порог - 5%
- Swap: порог - 10%

Это уменьшает “дребезг” уведомлений, когда значение колеблется около порога.

---

#### Docker monitor

Включается только если:

- `ENABLE_DOCKER_MONITOR=1`
- установлен `docker` CLI
- `CONTAINERS` непустой

`CONTAINERS` — список через запятую:

- можно указывать **имя контейнера** (`nginx`) или **container id**.

Пример:

```dotenv
CONTAINERS="nginx, mysql, redis, 1a2b3c4d5e6f"
```

---

## Как скрипт работает с путями и файлами

### Где должен лежать `.env` (если используется)

Скрипт ищет `.env` **рядом с собой**, независимо от текущей директории запуска:

- `SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"` — абсолютный путь к папке, где лежит `monitor.sh`
- `ENV_FILE="${SCRIPT_DIR}/.env"` — ожидает `.env` **в той же папке**, что и `monitor.sh`

Пример:

```text
/opt/monitor/
  monitor.sh
  .env
```

Запуск возможен из любого места:

```bash
cd /tmp
/opt/monitor/monitor.sh
```

Если нужен `.env` в другом месте — измените строку:

```bash
ENV_FILE="${SCRIPT_DIR}/.env"
```

на нужный путь. Если `.env` отсутствует — скрипт продолжит работу с дефолтными настройками.

---

### Куда пишутся state / logs / lock (по умолчанию)

По умолчанию скрипт использует:

- `STATE_FILE=$HOME/.local/state/monitor/state.json` — состояние (счётчики, down/up, алерты)
- `LOG_FILE=$HOME/.local/state/monitor/monitor.log` — лог выполнения
- `LOCK_FILE=$HOME/.local/state/monitor/monitor.lock` — блокировка от параллельных запусков

Директории под `STATE_FILE` и `LOG_FILE` создаются автоматически:

```bash
mkdir -p "$(dirname "$STATE_FILE")" "$(dirname "$LOG_FILE")"
```

Если вы переопределяете `LOCK_FILE` в другой каталог — убедитесь, что директория существует.

---

### Как переопределять пути через `.env`

Так как `.env` загружается до установки дефолтов, вы можете задать пути прямо в `.env`:

```dotenv
PREFIX="[monitor][prod]"

STATE_FILE="/var/lib/monitor/state.json"
LOG_FILE="/var/log/monitor/monitor.log"
LOCK_FILE="/var/lock/monitor/monitor.lock"
```

---

### Права доступа и безопасность

В `.env` лежат секреты (TG_TOKEN), рекомендуемые права:

```bash
chmod 600 .env
```

---

### Как работает защита от параллельных запусков

Скрипт использует `flock`:

- если уже запущен другой экземпляр — новый завершится без ошибки (и запишет предупреждение в лог).

Это защищает от накладок, когда долгий запрос/проверка пересекается со следующим запуском cron/timer.

---

## Запуск по расписанию

### Cron (пример: раз в минуту)

Используйте **абсолютный путь** к скрипту:

```cron
* * * * * /opt/monitor/monitor.sh >/dev/null 2>&1
```

---

### systemd unit + timer (пример)

Создайте `/etc/systemd/system/server-monitor.service`:

```ini
[Unit]
Description=Server Monitor

[Service]
Type=oneshot
WorkingDirectory=/opt/monitor
ExecStart=/opt/monitor/monitor.sh
```

Создайте `/etc/systemd/system/server-monitor.timer`:

```ini
[Unit]
Description=Run Server Monitor every minute

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
AccuracySec=5s

[Install]
WantedBy=timers.target
```

Включение:

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now server-monitor.timer
sudo systemctl status server-monitor.timer
```

---

## Что мониторится

### HTTP

- доступность `URLS`;
- таймаут (`HTTP_TIMEOUT`);
- подтверждение падения после N ошибок подряд (`HTTP_FAIL_THRESHOLD`);
- уведомление о падении и восстановлении.
- предупреждение, если сайт доступен, но локальные web‑службы остановлены.

### Хост

- CPU
- RAM
- диск `/`
- swap

### Docker (опционально)

- состояние контейнеров по имени или ID из `CONTAINERS`.

---

## Почему используем /proc и df, а не top/free/lsblk и сторонние утилиты

Проект ориентирован на минимальный overhead и предсказуемое поведение в cron/systemd timer. Поэтому метрики берутся из стабильных системных источников Linux (в первую очередь `/proc`) и простых утилит с устойчивым форматом вывода.

### CPU: `/proc/stat`, а не `top`

- `top` — интерактивный инструмент; даже в batch-режиме он тяжелее чтения `/proc`.
- Формат вывода `top` зависит от версии/локали/настроек — парсинг хрупкий.
- Для алертинга нужен корректный процент за интервал — проще считать дельту счётчиков из `/proc/stat`.

### Почему 0–100%, а не 1200% на 12 ядрах
`cpu_usage_pct()` читает суммарные счётчики из `/proc/stat` и считает долю busy за короткий интервал. Это даёт нормализованный процент 0–100, где 100% означает, что все CPU были заняты в среднем полностью.

Числа вроде “1200%” — это формат некоторых утилит (`top`/`htop`), которые суммируют нагрузку по ядрам. Для алертов нормализованный 0–100 удобнее: пороги одинаковы на 2 и на 32 CPU.

### RAM/Swap: `/proc/meminfo`, а не `free`

- `free` — обёртка над теми же данными, но формат вывода зависит от версии и ключей.
- `/proc/meminfo` — первичный стабильный источник, удобно парсится через `awk`.
- Используется `MemAvailable` — практичнее, чем “free” в классическом смысле.

### Disk usage: `df -P`, а не `lsblk`

- цель метрики — занятость файловой системы (`/`), а не инвентаризация устройств.
- `lsblk` даёт дерево устройств/разделов и требует сложного парсинга.
- `df -P` предоставляет POSIX-формат, устойчивый для парсинга.

### Почему не `mpstat/sar/vmstat` (sysstat)

- дополнительные зависимости (часто отсутствуют на минимальных VPS);
- некоторые сценарии требуют фоновых сборщиков, что противоречит модели “запуск и выход”;
- форматы вывода зависят от версии — выше риск несовместимости.

---

## ShellCheck

Рекомендуется прогонять скрипт через ShellCheck:

```bash
shellcheck monitor.sh
```

---

## Тесты / демо

Простейшие тесты с моками `curl`/`systemctl` можно запустить через Makefile:

```bash
make test
```

Также доступна проверка линтером (если установлен ShellCheck):

```bash
make lint
```

Для запуска команд через Makefile нужен установленный `make`.

Установка `make`:

```bash
# Debian/Ubuntu
sudo apt-get update -y && sudo apt-get install -y make

# RHEL/CentOS/Rocky/Alma
sudo dnf install -y make

# Arch
sudo pacman -Sy --noconfirm make
```

---

## Troubleshooting

### `.env not found`

Сообщение:

- `WARN: .env not found: ...`

Решение:
-- убедитесь, что `.env` лежит **рядом с `monitor.sh`**;

- если `.env` отсутствует сознательно — это нормально, скрипт продолжит работу с дефолтами.
- или измените `ENV_FILE` в скрипте.

---

### Нет утилит (`jq`, `curl`, `flock` и т.д.)

Решение:

- запустите `./bootstrap.sh`;
- или установите утилиты вручную (в зависимости от дистрибутива).

---

### Не приходят сообщения в Telegram

Проверьте:

- `TG_TOKEN` корректен (и не “обрезан”);
- `TG_CHAT` — именно numeric chat id;
- бот “видит” чат (вы писали ему, он получал updates);
- доступ к `api.telegram.org` с сервера не блокируется.

---

### Docker мониторинг не срабатывает

Проверьте:

- `ENABLE_DOCKER_MONITOR=1`
- установлен `docker` CLI
- у пользователя, запускающего скрипт, есть права на docker (обычно группа `docker`)

---

## Security notes

- Никогда не коммитьте `.env` в репозиторий.
- Держите права на `.env` минимальными: `chmod 600 .env`
- Для запуска по расписанию предпочтительно использовать отдельного пользователя с ограниченными правами, если это соответствует вашей модели безопасности.
